<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Brokenswing</title><link>blog.brokenswing.fr/</link><description>Recent content on Brokenswing</description><generator>Hugo</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener"&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Sat, 02 Apr 2022 22:22:56 +0200</lastBuildDate><atom:link href="blog.brokenswing.fr/index.xml" rel="self" type="application/rss+xml"/><item><title>Python Profiler</title><link>blog.brokenswing.fr/posts/python-profiler/</link><pubDate>Sat, 02 Apr 2022 22:22:56 +0200</pubDate><guid>blog.brokenswing.fr/posts/python-profiler/</guid><description>&lt;p&gt;Profiling a program allows to detect bottlenecks to optimize either memory or speed of this one. Profiling is achieved in different ways depending the language but Python allows to very easily provide a profiler.&lt;/p&gt;
&lt;p&gt;In this article we will quickly see the features of the default profiler provided by Python then we will explore the world of writing it&amp;rsquo;s own profiler.&lt;/p&gt;
&lt;h2 id="python-profile-and-cprofile-modules"&gt;Python &lt;code&gt;profile&lt;/code&gt; and &lt;code&gt;cProfile&lt;/code&gt; modules&lt;/h2&gt;
&lt;p&gt;Python provides two implementations of profilers: &lt;code&gt;profile&lt;/code&gt; and &lt;code&gt;cProfile&lt;/code&gt;. However it&amp;rsquo;s recommended to use &lt;code&gt;cProfile&lt;/code&gt; because, as the name suggests, it&amp;rsquo;s a C implementation and therefore has less overhead, leading to better results.&lt;/p&gt;</description></item></channel></rss>